package com.example.spoteam_android.ui.study.todolist

import StudyApiService
import StudyViewModel
import android.content.Context
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewTreeObserver
import android.view.inputmethod.InputMethodManager
import android.widget.ImageButton
import android.widget.Toast
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProvider
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.spoteam_android.MemberResponse
import com.example.spoteam_android.ProfileItem
import com.example.spoteam_android.RetrofitInstance
import com.example.spoteam_android.databinding.FragmentTodoListBinding
import com.example.spoteam_android.ui.study.calendar.CalendarApiService
import com.example.spoteam_android.ui.study.calendar.Event
import com.example.spoteam_android.ui.study.calendar.EventAdapter
import com.example.spoteam_android.ui.study.calendar.EventViewModel
import com.example.spoteam_android.ui.study.calendar.ScheduleResponse
import com.example.spoteam_android.ui.study.DetailStudyHomeProfileAdapter
import com.prolificinteractive.materialcalendarview.CalendarDay
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import java.time.DayOfWeek
import java.time.LocalDate
import java.util.Calendar
import java.time.YearMonth

class TodoListFragment : Fragment() {

    private lateinit var binding: FragmentTodoListBinding
    private lateinit var todoViewModel: TodoViewModel
    private val studyViewModel: StudyViewModel by activityViewModels()
    private lateinit var myTodoAdapter: TodoAdapter
    private lateinit var otherTodoAdapter: OtherTodoAdapter
    private lateinit var todoEventAdapter: TodoEventAdapter
    private lateinit var todoDateAdapter: TodoDateAdapter
    private lateinit var selectedDate: String // Î©§Î≤Ñ Î≥ÄÏàòÎ°ú ÏÑ†Ïñ∏
    private val eventViewModel: EventViewModel by activityViewModels()
    private lateinit var profileAdapter: DetailStudyHomeProfileAdapter
    private lateinit var memberIdMap: Map<ProfileItem, Int>
    private var selectedMemberId: Int? = null
    private lateinit var repository: TodoRepository // repository ÏÑ†Ïñ∏

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        binding = FragmentTodoListBinding.inflate(inflater, container, false)


        // Ìà¨ÎëêÎ¶¨Ïä§Ìä∏ EdixText Îã§Î•∏ Í≥≥ ÌÅ¥Î¶≠ Ïãú Ìè¨Ïª§Ïã± Ìï¥Ï†ú
        binding.root.setOnTouchListener { view, _ ->
            view.performClick()
            val focusedView = activity?.currentFocus
            if (focusedView != null) {
                val imm = requireContext().getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
                imm.hideSoftInputFromWindow(focusedView.windowToken, 0)
                focusedView.clearFocus()
            }

            myTodoAdapter.cancelIfEditing()

            false
        }

        val studyId = studyViewModel.studyId.value ?: 0

        val apiService = RetrofitInstance.retrofit.create(TodoApiService::class.java)
        repository = TodoRepository(apiService) // Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ
        val factory = TodoViewModelFactory(repository, studyId)
        todoViewModel = ViewModelProvider(this, factory).get(TodoViewModel::class.java)

        // Ïò§Îäò ÎÇ†ÏßúÎ°ú selectedDate Ï¥àÍ∏∞Ìôî
        val calendar = Calendar.getInstance()
        val year = calendar.get(Calendar.YEAR)
        val month = calendar.get(Calendar.MONTH) + 1 // Calendar.MONTHÎäî 0Î∂ÄÌÑ∞ ÏãúÏûë
        val today = calendar.get(Calendar.DAY_OF_MONTH)

        val currentYear = LocalDate.now().year // ÌòÑÏû¨ Ïó∞ÎèÑ
        val currentMonth = LocalDate.now().monthValue // ÌòÑÏû¨ Ïõî

        Log.d("Todo","1111")

        Log.d("Todo","${getTotalWeeksInMonth(currentYear,currentMonth)}")

        val daysOfCurrentMonth = getDaysOfMonthWithPadding(currentYear, currentMonth)


        var selectedDate2 = 1


        todoDateAdapter = TodoDateAdapter(daysOfCurrentMonth, selectedDate2) { newSelectedDate ->
            selectedDate2 = newSelectedDate
            todoDateAdapter.updateDates(daysOfCurrentMonth, selectedDate2)
        }

        binding.rvCalendar.layoutManager = LinearLayoutManager(requireContext(), LinearLayoutManager.HORIZONTAL, false)
        binding.rvCalendar.adapter = todoDateAdapter



        selectedDate  = "${calendar.get(Calendar.YEAR)}-" +
                "${(calendar.get(Calendar.MONTH) + 1).toString().padStart(2, '0')}-" +
                "${calendar.get(Calendar.DAY_OF_MONTH).toString().padStart(2, '0')}"

        // Î¶¨ÏÇ¨Ïù¥ÌÅ¥Îü¨Î∑∞ Ï¥àÍ∏∞Ìôî, Î≥ÄÏàò ÏÑ†Ïñ∏Îì± UI ÌëúÏãú Ïù¥Ï†ÑÏóê ÏÑ†ÌñâÎêòÏñ¥Ïïº Ìï† ÏûëÏóÖ ÏàòÌñâ

        todoEventAdapter = TodoEventAdapter(emptyList(), { /* ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ (ÌïÑÏöîÏãú Ï∂îÍ∞Ä) */ }, true)
        binding.eventrecyclerviewto.layoutManager = LinearLayoutManager(requireContext())
        binding.eventrecyclerviewto.adapter = todoEventAdapter

        profileAdapter = DetailStudyHomeProfileAdapter(
            ArrayList(),
            { profileItem ->
                val memberId = memberIdMap[profileItem]
                if (memberId != null) {
                    selectedMemberId = memberId
                    fetchOtherTodoList(studyId, memberId, selectedDate)
                }
            },
            isTodo = true // ‚Üê Ïó¨Í∏∞ trueÎ°ú ÎÑòÍπÄ
        )

        binding.fragmentDetailStudyHomeProfileRv.layoutManager = LinearLayoutManager(requireContext(), LinearLayoutManager.HORIZONTAL, false)
        binding.fragmentDetailStudyHomeProfileRv.adapter = profileAdapter

        //ÎÇ¥ Ìà¨ÎëêÎ¶¨Ïä§Ìä∏
        myTodoAdapter = TodoAdapter(
            context = requireContext(),
            todoList = mutableListOf(),
            onAddTodo = { content ->
                todoViewModel.addTodoItem(studyId, content, selectedDate)
            },
            onCheckTodo = { toDoId ->
                todoViewModel.checkTodo(studyId, toDoId)
            },
            repository = repository, // TodoRepository Ï†ÑÎã¨
            studyId = studyId // Ïä§ÌÑ∞Îîî ID Ï†ÑÎã¨
        )

        binding.rvMyTodoList.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = myTodoAdapter
        }

        //Îã§Î•∏ Ïä§ÌÑ∞ÎîîÏõê Ìà¨ÎëêÎ¶¨Ïä§Ìä∏
        otherTodoAdapter = OtherTodoAdapter(requireContext(), mutableListOf())

        binding.rvOtherTodo.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = otherTodoAdapter
        }


        // ÏµúÏ¥à Ìà¨ÎëêÎ¶¨Ïä§Ìä∏, Ïä§ÏºÄÏ•¥ Ï°∞Ìöå
        todoViewModel.onDateChanged(selectedDate)
        fetchTodoList(studyId, today.toString().padStart(2, '0'))

        //Ï∫òÎ¶∞Îçî ÏùºÏ†ï Ï°∞Ìöå API ÏµúÏ¥à Ìò∏Ï∂ú
        fetchGetSchedule(studyId, year, month) {
            eventViewModel.loadEvents(year, month, today)

            // Ïñ¥ÎåëÌÑ∞ÏôÄ Îç∞ÏΩîÎ†àÏù¥ÌÑ∞ Í∞±Ïã† Ï∂îÍ∞Ä
            todoEventAdapter.updateSelectedDate(selectedDate)

            // Ïñ¥ÎåëÌÑ∞ Îç∞Ïù¥ÌÑ∞ Í∞±Ïã†
            todoEventAdapter.updateEvents(eventViewModel.events.value ?: emptyList())

            todoEventAdapter.updateSelectedDate(selectedDate)
            eventViewModel.events.value?.let { todoEventAdapter.updateEvents(it) }

            val updatedEventDays = getEventDaysForMonth(currentYear, currentMonth)
            todoDateAdapter.updateEventDays(updatedEventDays)


            // ‚úÖ ÏÑ†ÌÉùÌïú ÎÇ†ÏßúÏóê Ïù¥Î≤§Ìä∏Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
            val hasEvent = todoEventAdapter.hasEventOnDay(today)
            binding.txScheduledEvent.visibility = if (hasEvent) View.VISIBLE else View.GONE
        }




        // ‚úÖ Í∏∞Ï°¥ selectedDate Î≥ÄÏàòÎ•º Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
        todoDateAdapter = TodoDateAdapter(daysOfCurrentMonth, today) { newSelectedDate ->
            selectedDate = formatToDate("$currentYear-${currentMonth.toString().padStart(2, '0')}-${newSelectedDate.toString().padStart(2, '0')}")

            // ‚úÖ ÎÇ†Ïßú ÏÑ†ÌÉù Ïãú UI Î∞òÏòÅ
            todoDateAdapter.updateDates(daysOfCurrentMonth, newSelectedDate)

            // ‚úÖ ÏÑ†ÌÉùÎêú ÎÇ†ÏßúÏóê ÎåÄÌïú API ÏöîÏ≤≠ Ïã§Ìñâ
            todoViewModel.onDateChanged(selectedDate)
            fetchTodoList(studyId, newSelectedDate.toString().padStart(2, '0'))

            fetchGetSchedule(studyId, currentYear, currentMonth) {
                eventViewModel.loadEvents(currentYear, currentMonth, newSelectedDate)
                todoEventAdapter.updateSelectedDate(selectedDate)
                eventViewModel.events.value?.let { todoEventAdapter.updateEvents(it) }

                Log.d("checkList", "üì¶ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§Ìä∏: ${eventViewModel.events.value}")

                val updatedEventDays = getEventDaysForMonth(currentYear, currentMonth)
                todoDateAdapter.updateEventDays(updatedEventDays)

                val hasEvent = todoEventAdapter.hasEventOnDay(today)
                binding.txScheduledEvent.visibility = if (hasEvent) View.VISIBLE else View.GONE
            }

            // ‚úÖ Í∏∞Ï°¥Ïùò otherTodoList Ï¥àÍ∏∞Ìôî
            profileAdapter.resetBorder()
            todoViewModel.clearOtherTodoList()
            otherTodoAdapter.clearData()
        }


        binding.rvCalendar.adapter = todoDateAdapter

        scrollToTodayPosition()



        // ÎÇ¥ Ìà¨ÎëêÎ¶¨Ïä§Ìä∏ Ï°∞Ìöå API
        todoViewModel.myTodoListResponse.observe(viewLifecycleOwner) { response ->
            response?.result?.content?.let { todos ->
                // Î∞õÏùÄ Îç∞Ïù¥ÌÑ∞Í∞Ä Ïù¥Ï†ÑÍ≥º ÎèôÏùºÌïú Í≤ΩÏö∞ RecyclerViewÎ•º Í∞±Ïã†ÌïòÏßÄ ÏïäÏùå
                if (todos != myTodoAdapter.getCurrentData()) {
                    val reversedTodos = todos.reversed() // Ïó≠ÏàúÏúºÎ°ú Ï†ïÎ†¨
                    myTodoAdapter.updateData(reversedTodos.toMutableList())
                }
            } ?: run {
                myTodoAdapter.updateData(emptyList<TodoTask>().toMutableList())
            }

        }

        // Ïä§ÌÑ∞ÎîîÏõê Ìà¨ÎëêÎ¶¨Ïä§Ìä∏ Ï°∞Ìöå API
        todoViewModel.otherTodoListResponse.observe(viewLifecycleOwner) { response ->
            response?.result?.content?.let { todos ->
                Log.d("TodoFramgment_other","${todos}")

                if (todos.isNotEmpty()) {
                    otherTodoAdapter.updateData(todos.toMutableList())
                } else {
                    otherTodoAdapter.updateData(emptyList())
                }
            } ?: run {
                otherTodoAdapter.updateData(emptyList())
            }
        }



        // + Î≤ÑÌäºÏùÑ ÌÜµÌï¥ ÎÇ¥ Ìà¨ÎëêÎ¶¨Ïä§Ìä∏Î•º Ï∂îÍ∞ÄÌï† Ïàò ÏûàÏùå
        binding.imgbtnPlusTodolist.setOnClickListener {
            myTodoAdapter.addTodo(selectedDate)
            binding.rvMyTodoList.scrollToPosition(myTodoAdapter.itemCount - 1)
        }

        //Ïä§ÌÑ∞ÎîîÏõê ÌîÑÎ°úÌïÑ Ï°∞Ìöå API Ìò∏Ï∂ú
        fetchStudyMembers(studyId)

        val eventDays = getEventDaysForMonth(currentYear, currentMonth)
        todoDateAdapter.updateEventDays(eventDays)



        return binding.root
    }


    // ÎÇ¥ Ìà¨ÎëêÎ¶¨Ïä§Ìä∏ Ï°∞Ìöå
    private fun fetchTodoList(studyId: Int, date:String) {

        val calendar = Calendar.getInstance()
        val formattedDate = formatToDate("${calendar.get(Calendar.YEAR)}-" +
                "${(calendar.get(Calendar.MONTH) + 1).toString().padStart(2, '0')}-" +
                date)
        todoViewModel.fetchTodoList(studyId, page = 0, size = 10, date = formattedDate)

        todoViewModel.myTodoListResponse.observe(viewLifecycleOwner) { response ->
            response?.result?.content?.let { todos ->
                // Îç∞Ïù¥ÌÑ∞Î•º Ïó≠ÏàúÏúºÎ°ú Ï†ïÎ†¨
                val reversedTodos = todos.reversed()
                myTodoAdapter.updateData(reversedTodos.toMutableList())
            } ?: run {
                myTodoAdapter.updateData(emptyList<TodoTask>().toMutableList())
            }
        }
    }


    // Ïä§ÌÑ∞ÎîîÏõê Ìà¨Îëê Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
    private fun fetchOtherTodoList(studyId: Int, memberId: Int, date: String) {

        todoViewModel.fetchOtherToDoList(studyId, memberId, page = 0, size = 10, date = date)
        todoViewModel.otherTodoListResponse.observe(viewLifecycleOwner) { response ->
            response?.result?.content?.let { todos ->
                // Îç∞Ïù¥ÌÑ∞Î•º Ïó≠ÏàúÏúºÎ°ú Ï†ïÎ†¨
                val reversedTodos = todos.reversed()
                otherTodoAdapter.updateData(reversedTodos.toMutableList())
            } ?: run {
                otherTodoAdapter.updateData(emptyList())
            }
        }
    }



    //ÎÇ†Ïßú ÌòïÏãù Ï°∞Ï†ï
    private fun formatToDate(date: String): String {
        val parts = date.split("-")
        return if (parts.size == 3) {
            String.format("%04d-%02d-%02d", parts[0].toInt(), parts[1].toInt(), parts[2].toInt())
        } else {
            date // Ïù¥ÎØ∏ Ìè¨Îß∑Ïù¥ ÎßûÎäî Í≤ΩÏö∞ Í∑∏ÎåÄÎ°ú Î∞òÌôò
        }
    }


    // Ï∫òÎ¶∞Îçî ÏùºÏ†ï Ï°∞Ìöå
    private fun fetchGetSchedule(studyId: Int, year: Int, month: Int, onComplete: () -> Unit) {

        val EventItems = arrayListOf<Event>()
        val service = RetrofitInstance.retrofit.create(CalendarApiService::class.java)

        service.GetScheuled(
            studyId = studyId,
            year = year,
            month = month,
        ).enqueue(object : Callback<ScheduleResponse> {
            override fun onResponse(
                call: Call<ScheduleResponse>,
                response: Response<ScheduleResponse>
            ) {
                if (response.isSuccessful) {
                    val apiResponse = response.body()

                    if (apiResponse?.isSuccess == true) {
                        // EventItems Îç∞Ïù¥ÌÑ∞ Î°úÎìú
                        apiResponse.result.scheduleList.forEach { schedule ->
                            val eventItem = Event(
                                id = schedule.scheduleId,
                                title = schedule.title,
                                startYear = schedule.startedAt.substring(0, 4).toInt(),
                                startMonth = schedule.startedAt.substring(5, 7).toInt(),
                                startDay = schedule.startedAt.substring(8, 10).toInt(),
                                startHour = schedule.startedAt.substring(11, 13).toInt(),
                                startMinute = schedule.startedAt.substring(14, 16).toInt(),
                                endYear = schedule.finishedAt.substring(0, 4).toInt(),
                                endMonth = schedule.finishedAt.substring(5, 7).toInt(),
                                endDay = schedule.finishedAt.substring(8, 10).toInt(),
                                endHour = schedule.finishedAt.substring(11, 13).toInt(),
                                endMinute = schedule.finishedAt.substring(14, 16).toInt(),
                                period = schedule.period,
                                isAllDay = schedule.isAllDay
                            )
                            EventItems.add(eventItem)
                        }
                        // ViewModel Î∞è AdapterÏóê Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                        eventViewModel.updateEvents(EventItems)

                        todoEventAdapter.updateEvents(EventItems)

                        // ÏΩúÎ∞± Ìò∏Ï∂ú
                        onComplete()
                    }
                }
            }



            override fun onFailure(call: Call<ScheduleResponse>, t: Throwable) {
                TODO("Not yet implemented")
            }
        })
    }

    // Ïä§ÌÑ∞Îîî Î©§Î≤Ñ Ï°∞Ìöå
    private fun fetchStudyMembers(studyId: Int) {
        val api = RetrofitInstance.retrofit.create(StudyApiService::class.java)

        val sharedPreferences = requireActivity().getSharedPreferences("MyPrefs", Context.MODE_PRIVATE)
        val email = sharedPreferences.getString("currentEmail", null)
        val kakaoNickname = sharedPreferences.getString("${email}_nickname", null)

        api.getStudyMembers(studyId).enqueue(object : Callback<MemberResponse> {
            override fun onResponse(call: Call<MemberResponse>, response: Response<MemberResponse>) {
                if (response.isSuccessful) {
                    response.body()?.let { memberResponse ->

                        val members = memberResponse.result.members

                        // ProfileItem ÏÉùÏÑ±
                        val profileItems = members.map {
                            ProfileItem(
                                profileImage = it.profileImage,
                                nickname = it.nickname
                            )
                        }

                        // ProfileItemÍ≥º memberId Îß§Ìïë
                        memberIdMap = members.associateBy(
                            keySelector = { ProfileItem(profileImage = it.profileImage, nickname = it.nickname) },
                            valueTransform = { it.memberId }
                        )

                        // RecyclerView ÏóÖÎç∞Ïù¥Ìä∏
                        profileAdapter.updateList(profileItems)

                        // ÎãâÎÑ§ÏûÑ Î¶¨Ïä§Ìä∏ÏóêÏÑú ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÏùò ÎãâÎÑ§ÏûÑÍ≥º ÏùºÏπòÌïòÎäîÏßÄ ÌôïÏù∏
                        val nicknames = members.map { it.nickname }
                        val isNicknameFound = kakaoNickname?.let { nicknames.contains(it) } ?: false

                        // maxPeopleÍ≥º memberCount Í∞íÏùÑ Í∞ÄÏ†∏Ïò§Í∏∞ ÏúÑÌï¥ ViewModelÏùÑ ÏòµÏ†ÄÎπô
                        val maxPeople = studyViewModel.maxPeople.value
                        val memberCount = studyViewModel.memberCount.value

                        // ÎãâÎÑ§ÏûÑÏù¥ Î¶¨Ïä§Ìä∏Ïóê ÏûàÍ±∞ÎÇò, memberCountÏôÄ maxPeopleÏù¥ ÏùºÏπòÌïòÎ©¥ Î≤ÑÌäºÏùÑ Ïà®ÍπÄ
                        val isMember = isNicknameFound
                        if (isMember){
                            binding.imgbtnPlusTodolist.visibility = View.VISIBLE
                        }else{
                            binding.imgbtnPlusTodolist.visibility = View.GONE
                        }



                        // RecyclerViewÏùò Ï†úÏïΩ Ï°∞Í±¥ ÏÑ§Ï†ï
                        val layoutParams = binding.fragmentDetailStudyHomeProfileRv.layoutParams as ConstraintLayout.LayoutParams
                        binding.fragmentDetailStudyHomeProfileRv.layoutParams = layoutParams
                    }
                } else {
                    Toast.makeText(requireContext(), "Failed to fetch study members", Toast.LENGTH_SHORT).show()
                }
            }

            override fun onFailure(call: Call<MemberResponse>, t: Throwable) {
                Toast.makeText(requireContext(), "Error: ${t.message}", Toast.LENGTH_SHORT).show()
            }
        })
    }


    fun getDaysOfMonthWithPadding(year: Int, month: Int): List<Triple<Int?, Boolean, Boolean>> {
        val yearMonth = YearMonth.of(year, month)
        val daysInMonth = yearMonth.lengthOfMonth()

        // üîπ Ïù¥Î≤à Îã¨ 1ÏùºÏùò ÏöîÏùº Í∞ÄÏ†∏Ïò§Í∏∞ (ÏõîÏöîÏùº=1, ÏùºÏöîÏùº=7)
        val firstDayOfMonth = LocalDate.of(year, month, 1).dayOfWeek.value

        // üîπ ÏõîÏöîÏùºÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨ÌïòÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú Îπà Ïπ∏ Í∞úÏàò Í≥ÑÏÇ∞
        val startPadding = if (firstDayOfMonth == 1) 0 else firstDayOfMonth - 1

        // üîπ Ïù¥Ï†Ñ Îã¨ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
        val previousMonth = if (month == 1) 12 else month - 1
        val previousYear = if (month == 1) year - 1 else year
        val previousMonthDays = YearMonth.of(previousYear, previousMonth).lengthOfMonth()

        val daysList = mutableListOf<Triple<Int?, Boolean, Boolean>>() // (ÎÇ†Ïßú, ÌòÑÏû¨ Îã¨ Ïó¨Î∂Ä, ÌÅ¥Î¶≠ Í∞ÄÎä• Ïó¨Î∂Ä)


        // ‚úÖ ÌòÑÏû¨ ÏõîÏùò ÎÇ†Ïßú Ï∂îÍ∞Ä (Ï†ïÏÉÅ Ï≤òÎ¶¨)
        for (i in 1..daysInMonth) {
            daysList.add(Triple(i, true, true)) // ÌòÑÏû¨ Îã¨, ÌÅ¥Î¶≠ Í∞ÄÎä•
        }

        return daysList
    }



    fun getTotalWeeksInMonth(year: Int, month: Int): Int {
        val daysList = getDaysOfMonthWithPadding(year, month)
        return (daysList.size + 6) / 7 // 7ÏùºÏî© ÎÇòÎàÑÍ≥† Ïò¨Î¶º Ï≤òÎ¶¨
    }

    // ‚úÖ Ïò§Îäò ÎÇ†ÏßúÎ•º RecyclerView Ï§ëÏïôÏóê Ï†ïÎ†¨ÌïòÎäî Ìï®Ïàò
    private fun scrollToTodayPosition() {
        val today = Calendar.getInstance().get(Calendar.DAY_OF_MONTH) // Ïò§Îäò ÎÇ†Ïßú Í∞ÄÏ†∏Ïò§Í∏∞
        val todayPosition = todoDateAdapter.getPositionForDate(today) // Ïò§Îäò ÎÇ†ÏßúÏùò ÏúÑÏπò Ï∞æÍ∏∞

        if (todayPosition != -1) {
            binding.rvCalendar.viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {
                override fun onGlobalLayout() {
                    binding.rvCalendar.viewTreeObserver.removeOnGlobalLayoutListener(this)

                    val childView = binding.rvCalendar.getChildAt(0)
                    val offset = binding.rvCalendar.width / 2 - (childView?.width ?: 0) / 2
                    (binding.rvCalendar.layoutManager as LinearLayoutManager).scrollToPositionWithOffset(todayPosition, offset)
                }
            })
        }
    }

    fun getEventDaysForMonth(year: Int, month: Int): Set<Int> {
        val days = mutableSetOf<Int>()

        // ‚úÖ ViewModelÏùò Ïù¥Î≤§Ìä∏ Ï†ÑÏ≤¥ ÎÇ†ÏßúÏóêÏÑú ÌòÑÏû¨ ÏõîÏóê Ìï¥ÎãπÌïòÎäî Í≤ÉÎßå ÌïÑÌÑ∞ÎßÅ
        val allEventDays = eventViewModel.getEventDates()

        allEventDays.forEach { calendarDay ->
            if (calendarDay.year == year && calendarDay.month == month) {
                days.add(calendarDay.day)
            }
        }

        Log.d("eventDaySet", "üìÖ ${year}ÎÖÑ ${month}Ïõî Í∏∞Ï§Ä ÌååÎûÄ Ï†ê Ï∞çÌûê ÎÇ†ÏßúÎì§: $days")
        return days
    }



}